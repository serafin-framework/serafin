# The (infamous) Pet Store

For this walkthrough we will develop a simple Pet Store API.


## Prerequisites

The code is already available under `src/example/petstore` folder. If you clone this repo, you will be able to run it as a docker container directly.

If you prefer to code it from scratch, we assume that you have at least :
- `node.js` installed
- `typescript` installed
- `@serafin/api` and  `@serafin/schema-builder` installed in your project

## Setup API

The `Api` class is used to bind transports to express and register your pipelines. It also define the general information about your API. Let's initialize it :

```typescript
let app = express();
app.use(bodyParser.json());
let api = new Api(app, {
    "openapi": "3.0.0",
    "info": {
        "version": "1.0.0",
        "title": "Sample Petstore Api",
        "description": "Sample Petstore Api",
        "termsOfService": "None",
        "license": {
            "name": "MIT"
        }
    },
    "servers": [{
        "url": "http://127.0.0.1",
        "description": "development server"
    }],
    paths: {}
});
```
Our `api` object has three important things :

- a `use` method to register pipelines
- a `configure` method to add transports
- an `openApi` property which is the Open API document

## Setup transports

Now that we have define the `Api`, we can configure our transports. `RestTransport` will take care of creating RESTfull enpoints and adding them to the OpenApi document. `GraphQLTransport` will take care of exposing a `/graphql` endpoint and creating the associated graphql schema.

```typescript
api.configure(new RestTransport())
    .configure(new GraphQLTransport({
        graphiql: true,
        schema: true
    }));
```

## Pet model schema definition

The JSON schema is based on JSON Schema draft #7. Serafin provide a powerfull library to programatically create a Schema and its associated type at the same time.

So let's create our `Pet` schema.

```typescript
let petSchemaBuilder = SchemaBuilder.emptySchema()
  .addString("id", { description: "The identifier of the Pet. It is generated by the API." })
  .addString("name", { description: "The name of the Pet. If not provided the API generate one automatically.", example: "Snowball" })
  .addEnum("category", ["cat", "dog", "tiger"], { description: "The category of the pet." })
  .addArray("tags", SchemaBuilder.stringSchema(), { description: "A list of tags to ease classification." }, false)
  .addArray("photoUrls", SchemaBuilder.stringSchema(), { description: "Urls to photos of this Pet." }, false)
```
Under the hood SchemaBuilder create a JSON Schema representation that contains what we have specified. You can access it this way:

```typescript
console.info(petSchemaBuilder.schema);
```

Thanks to the power of type operations in Typescript (&, |, keyof, generics, type constraints, etc.), the ```petSchemaBuilder``` has already a generic type that represents a ```Pet``` object.

## Pipeline initialization

Let's come back to our `Api`. Now that we have the Pet schema, we can initialize our first pipeline :

```typescript
let petPipeline = new PipelineSourceInMemory(petSchemaBuilder)
```

The ```petSchemaBuilder``` directly affects the generic types of the pipeline.

`petPipeline` will store data into memory and will follow the directives of `petSchemaBuilder` for validating data. It provides the following operation:

- `read`
- `create`
- `replace`
- `patch` which support merge patch algorithm as defined in RFC 7396
- `delete`

It also exposes important properties :
- `*SchemaBuilder` which are all the schema builders that controls wwhat comes in and out of the pipeline.
- `relations` which is the collection of relations defined for this pipeline.

## Combining behaviors

The default behavior of `PipelineSourceInMemory` is pretty basic. It could be nice to add some additional capabilities. Let's add pagination for this example (the class is provided by Serafin).

```
let petPipeline = (new PipelineSourceInMemory(petSchema))
    .pipe(new Paginate())
```

If you look closely at your typings, you will see that when you use the `read` method, `options` now contains `count`, `offset` and `page`. The result also contains a new `count` property that wasn't here before.
The `.pipe(..)` does not only combine behavior, it also combines types.

For the sake of this example, let's create a custom pipeline. It will just generate a Pet name if we don't provide one.

```typescript
@description("Pipeline used to generate pet names if you don't have an idea.")
export class DefaultPetName extends PipeAbstract {
    constructor(private baseName: string, private currentCount: number = 0) {
        super();
    }

    private generatePetName() {
        return `${this.baseName} ${++this.currentCount}`
    }

    @description("Generate pet names for new Pets if they were not provided.")
    protected async _create(resources: { name: string }[], options?: {}) {
        resources.forEach(resource => {
            if (!resource.name) {
                resource.name = this.generatePetName()
            }
        });
        return this.parent.create(resources, options);
    }

    @description("Generate a new Pet name for the updated Pet if it was not provided.")
    protected async _update(id: string, values: { name: string }, options?: {}) {
        if (!values.name) {
            values.name = this.generatePetName()
        }
        return this.parent.update(id, values, options);
    }
}
```

We can then add it to our ```petPipeline```:

```typescript
let petPipeline = (new PipelineSourceInMemory(petSchema))
    .pipe(new Paginate())
    .pipe(new DefaultPetName("Snowball", 1))
```

Also a pipeline can be piped multiple times. It allows you to create tree like structures.

## Exposing the pipeline

We have defined an `Api` and we have a `Pipeline` but they are not yet linked together.

```typescript
api.use(petPipeline, "pet")
```

It basically tells the `Api` to expose the given `Pipeline` under the name `"pet"`. Each configured `Transport` receives the pipeline and can do its job to expose it properly.

## conclusion

We now have a fully working API with support for **OpenAPI 3** and **GraphQL**. This is only one endpoint with a simple behavior but things can get really interesting when you start having more.

`Relations` are not covered here. Take a look at the other examples and the code itself.


# Ready to run project

We will soon create a yeoman generator for you to get started quickly. It will provide a fully configured project with debugger and code coverage configured for *Visual Studio* users, *Typescript* and *gulp* tasks, and a *Docker* configuration to run your project as a *Docker* container.

# What's next?

If you haven't read it yet, you can take a look at our [overview document](./OVERVIEW.md).

In any case, please contact us on github to share your feedback and ideas. It will help us reach our next milestone =)
