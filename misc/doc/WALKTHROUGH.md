# The (infamous) Pet Store

For this walkthrough we will develop a simple Pet Store API. 


## Prerequisites

The code is already available under `src/example/petstore` folder. If you clone this repo, you will be able to run it as a docker container directly.

If you prefer to code it from scratch, we assume that you have at least :
- `node.js` installed
- `typescript` installed
- `gulp` installed
- a Typescript Express project with a build script
- `@serafin/api` and  `@serafin/gulp-serafin-json-schema-to-typescript` installed in your project

## Setup API

The `Api` class is used to bind transports to express and register your pipelines. It also define the general information about your API. Let's initialize it :

```typescript
let app = express();
app.use(bodyParser.json());
let api = new Api(app, {
    "openapi": "3.0.0",
    "info": {
        "version": "1.0.0",
        "title": "Sample Petstore Api",
        "description": "Sample Petstore Api",
        "termsOfService": "None",
        "license": {
            "name": "MIT"
        }
    },
    "servers": [{
        "url": "http://127.0.0.1",
        "description": "development server"
    }],
    paths: {}
});
```
Our `api` object has three important things :

- a `use` method to register pipelines
- a `configure` method to add transports
- an `openApi` property which is the Open API document

## Setup transports

Now that we have define the `Api`, we can configure our transports. `RestTransport` will take care of creating RESTfull enpoints and adding them to the OpenApi document. `GraphQLTransport` will take care of exposing a `/graphql` endpoint and creating the associated graphql schema.

```typescript
api.configure(new RestTransport())
    .configure(new GraphQLTransport({
        graphiql: true,
        schema: true
    }));
```

## Pet model schema definition

The schema is based on a mix of JSON Schema and Open Api specifications. In fact the one described in the Open API spec [here](https://swagger.io/specification/#schema-object-98).

So let's create a `pet.model.json`.

```json
{
    "type": "object",
    "title": "Pet",
    "description": "Schema of a Pet object.",
    "properties": {
        "id": {
            "type": "string",
            "description": "The identifier of the Pet. It is generated by the API."
        },
        "name": {
            "description": "The name of the Pet. If not provided the API generate one automatically.",
            "type": "string",
            "example": "Snowball"
        },
        "category": {
            "description": "The category of the pet.",
            "type": "string",
            "enum": [
                "cat",
                "dog",
                "tiger"
            ]
        },
        "tags": {
            "type": "array",
            "description": "A list of tags to ease classification.",
            "items": {
                "type": "string"
            }
        },
        "photoUrls": {
            "type": "array",
            "description": "Urls to photos of this Pet.",
            "items": {
                "type": "string"
            }
        }
    },
    "required": [
        "id",
        "name",
        "category"
    ],
    "additionalProperties": false
}
```
You can include in your schema additional `definitions`. Specificaly `createValues`, `updateValues`, `patchValues`, `patchQuery`, `deleteQuery`, `readQuery` are special. If provided, they are automatically taken in account for validating the appropriate pipeline action. If not provided default values are used.

Here we have two options:
- use the `gulp-serafin-json-schema-to-typescript` gulp task to generate typescript interfaces for this schema.
- or create typescript interfaces manually

We obviously recommend the first option but you're free to choose.

In all cases you will end up with the definition of the schema builder variable :

```typescript
export var petSchema = new PipelineSchemaBuilderModel<Pet, ReadQuery, CreateValues, UpdateValues, PatchQuery, PatchValues, DeleteQuery>(petJSONSchema, "Pet");
```

## Pipeline initialization

Let's come back to our `Api`. Now that we have the Pet schema, we can initialize our first pipeline :

```typescript
let petPipeline = new PipelineSourceInMemory(petSchema)
```

`petPipeline` will store data into memory and will follow the directives of `petSchema`. It provides the following operation:

- `read`
- `create`
- `update`
- `patch` which support merge patch algorithm as defined in RFC 7396
- `delete`

It also exposes two important properties :
- `schemaBuilder` which is the resulting schema of the pipeline. It combines the model schema and the options. It gather all modifications made by intermediate pipelines.
- `relations` which is the collection of relations defined for this pipeline.

## Combining behaviors

The default behavior of `PipelineSourceInMemory` is pretty basic. It could be nice to add some additional capabilities. Let's add pagination for this example (the class is provided by Serafin).

```
let petPipeline = (new PipelineSourceInMemory(petSchema))
    .pipe(new Paginate())
```

If you look closely at your typings, you will see that when you use the `read` method, `options` now contains `count`, `offset` and `page`. The result also contains a new `count` property that wasn't here before.
The `.pipe(..)` does not only combine behavior. It combines types.

For the sake of this example, let's create a custom pipeline. It will just generate a Pet name if we don't provide one.

```typescript
@description("Pipeline used to generate pet names if you don't have an idea.")
export class DefaultPetName extends PipelineAbstract {
    constructor(private baseName: string, private currentCount: number = 0) {
        super();
    }

    private generatePetName() {
        return `${this.baseName} ${++this.currentCount}`
    }

    @description("Generate pet names for new Pets if they were not provided.")
    protected async _create(resources: { name: string }[], options?: {}): Promise<{ name: string }[]> {
        resources.forEach(resource => {
            if (!resource.name) {
                resource.name = this.generatePetName()
            }
        });
        return this.parent.create(resources, options);
    }

    @description("Generate a new Pet name for the updated Pet if it was not provided.")
    protected async _update(id: string, values: { name: string }, options?: {}): Promise<{ name: string }> {
        if (!values.name) {
            values.name = this.generatePetName()
        }
        return this.parent.update(id, values, options);
    }
}
```

We can then add it to our existing pipeline:

```typescript
let petPipeline = (new PipelineSourceInMemory(petSchema))
    .pipe(new Paginate())
    .pipe(new DefaultPetName("Snowball", 1))
```

Also a pipeline can be piped multiple times. It allows you to create tree like structures.

## Exposing the pipeline

We have defined an `Api` and we have a `Pipeline` but they are not yet linked together.

```typescript
api.use(petPipeline, "pet")
```

It basically tells the `Api` to expose the given `Pipeline` under the name `"pet"`. Each configured `Transport` receives the pipeline and can do its job to expose it properly.

## conclusion

We now have a fully working API with support for **OpenAPI 3** and **GraphQL**. This is only one endpoint with a simple behavior but things will get really interesting when you start having more.

`Relations` are not covered here. Take a look at the other examples and the code itself. Until we create a fully documented website, it's your best option to get more insights.


# Ready to run project

We will soon create a yeoman generator for you to get started quickly. It will provide a fully configured project with debugger and code coverage configured for *Visual Studio* users, *Typescript* and *gulp* tasks, and a *Docker* configuration to run your project as a *Docker* container.

# What's next?

If you haven't read it yet, you can take a look at our [overview document](./OVERVIEW.md).

In any case, please contact us on github to share your feedback and ideas. It will help us reach our next milestone =)